学习笔记
我们可以设定两个下标 low 和 high，并设定 mid = （low + high）/2。 
我们自然就可以找到数组中间的元素 array[mid]，如果中间的元素位于前面的递增数组，那么它应该大于或者等于 low 下标对应的元素，此时数组中最小的元素应该位于该元素的后面，我们可以把 low 下标指向该中间元素，这样可以缩小查找的范围。 
同样，如果中间元素位于后面的递增子数组，那么它应该小于或者等于 high 下标对应的元素。此时该数组中最小的元素应该位于该中间元素的前面。我们就可以把 high 下标更新到中位数的下标，这样也可以缩小查找的范围，移动之后的 high 下标对应的元素仍然在后面的递增子数组中。
因为是有序数组的旋转，所以数组最后的元素一定不大于最初的元素。，所以我们的比较可以只选其中一个，代码中统一选择low所对应的元素进行比较。 
不管是更新 low 还是 high，我们的查找范围都会缩小为原来的一半，接下来我们再用更新的下标去重复新一轮的查找。直到最后两个下标相邻，也就是我们的循环结束条件。
例：
input：{3，4，5，1，2}
此时 low = 0，high = 4，mid = 2，对应的值分别是：num[low] = 3，num[high] = 2，num[mid] = 5
由于 num[mid] > num[low]，所以 num[mid] 应该是在左边的递增子数组中。
更新 low = mid = 2，num[low] = 5，mid = (low+high)/2 = 3，num[mid] = 1; 
high - low ≠ 1 ，继续更新。
由于 num[mid] < num[high]，所以断定 num[mid] = 1 位于右边的自增子数组中； 
更新 high = mid = 3，由于 high - low = 1,所以结束循环，得到最小值 num[high] = 1，high=3即为无序位置